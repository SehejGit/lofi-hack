// src/AuthContext.tsx
import { createContext, useContext, useEffect, useState, useRef } from "react";
import { jwtDecode } from "jwt-decode";

// src/sync/index.ts
import { v7 as uuidv7 } from "uuid";
import { Dexie as Dexie2 } from "dexie";
import "dexie-syncable";
import "dexie-observable";

// src/sync/syncProtocol.js
import { Dexie } from "dexie";

// src/config.ts
var SERVER_URL = "https://api.basic.tech";
var log = (...args) => {
  try {
    if (localStorage.getItem("basic_debug") === "true") {
      console.log("[basic]", ...args);
    }
  } catch (e) {
  }
};

// src/sync/syncProtocol.js
var syncProtocol = function() {
  log("Initializing syncProtocol");
  var RECONNECT_DELAY = 5e3;
  Dexie.Syncable.registerSyncProtocol("websocket", {
    sync: function(context, url, options, baseRevision, syncedRevision, changes, partial, applyRemoteChanges, onChangesAccepted, onSuccess, onError) {
      var requestId = 0;
      var acceptCallbacks = {};
      var ws = new WebSocket(url);
      function sendChanges(changes2, baseRevision2, partial2, onChangesAccepted2) {
        log("sendChanges", changes2.length, baseRevision2);
        ++requestId;
        acceptCallbacks[requestId.toString()] = onChangesAccepted2;
        ws.send(
          JSON.stringify({
            type: "changes",
            changes: changes2,
            partial: partial2,
            baseRevision: baseRevision2,
            requestId
          })
        );
      }
      ws.onopen = function(event) {
        log("Opening socket - sending clientIdentity", context.clientIdentity);
        ws.send(
          JSON.stringify({
            type: "clientIdentity",
            clientIdentity: context.clientIdentity || null,
            authToken: options.authToken,
            schema: options.schema
          })
        );
      };
      ws.onerror = function(event) {
        ws.close();
        log("ws.onerror", event);
        onError(event?.message, RECONNECT_DELAY);
      };
      ws.onclose = function(event) {
        onError("Socket closed: " + event.reason, RECONNECT_DELAY);
      };
      var isFirstRound = true;
      ws.onmessage = function(event) {
        try {
          var requestFromServer = JSON.parse(event.data);
          log("requestFromServer", requestFromServer, { acceptCallback, isFirstRound });
          if (requestFromServer.type == "clientIdentity") {
            context.clientIdentity = requestFromServer.clientIdentity;
            context.save();
            sendChanges(changes, baseRevision, partial, onChangesAccepted);
            ws.send(
              JSON.stringify({
                type: "subscribe",
                syncedRevision
              })
            );
          } else if (requestFromServer.type == "changes") {
            applyRemoteChanges(
              requestFromServer.changes,
              requestFromServer.currentRevision,
              requestFromServer.partial
            );
            if (isFirstRound && !requestFromServer.partial) {
              onSuccess({
                // Specify a react function that will react on additional client changes
                react: function(changes2, baseRevision2, partial2, onChangesAccepted2) {
                  sendChanges(
                    changes2,
                    baseRevision2,
                    partial2,
                    onChangesAccepted2
                  );
                },
                // Specify a disconnect function that will close our socket so that we dont continue to monitor changes.
                disconnect: function() {
                  ws.close();
                }
              });
              isFirstRound = false;
            }
          } else if (requestFromServer.type == "ack") {
            var requestId2 = requestFromServer.requestId;
            var acceptCallback = acceptCallbacks[requestId2.toString()];
            acceptCallback();
            delete acceptCallbacks[requestId2.toString()];
          } else if (requestFromServer.type == "error") {
            var requestId2 = requestFromServer.requestId;
            ws.close();
            onError(requestFromServer.message, Infinity);
          } else {
            log("unknown message", requestFromServer);
            ws.close();
            onError("unknown message", Infinity);
          }
        } catch (e) {
          ws.close();
          log("caught error", e);
          onError(e, Infinity);
        }
      };
    }
  });
};

// src/schema.ts
import Ajv from "ajv";
var basicJsonSchema = {
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "project_id": {
      "type": "string"
    },
    "namespace": {
      "type": "string"
    },
    "version": {
      "type": "integer",
      "minimum": 0
    },
    "tables": {
      "type": "object",
      "patternProperties": {
        "^[a-zA-Z0-9_]+$": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": ["collection"]
            },
            "fields": {
              "type": "object",
              "patternProperties": {
                "^[a-zA-Z0-9_]+$": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["string", "boolean", "number", "json"]
                    },
                    "indexed": {
                      "type": "boolean"
                    },
                    "required": {
                      "type": "boolean"
                    }
                  },
                  "required": ["type"]
                }
              },
              "additionalProperties": true
            }
          },
          "required": ["fields"]
        }
      },
      "additionalProperties": true
    }
  },
  "required": ["project_id", "version", "tables"]
};
var ajv = new Ajv();
var validator = ajv.compile(basicJsonSchema);
function validateSchema(schema) {
  const v = validator(schema);
  return {
    valid: v,
    errors: validator.errors || []
  };
}
function validateData(schema, table, data, checkRequired = true) {
  const valid = validateSchema(schema);
  if (!valid.valid) {
    return { valid: false, errors: valid.errors, message: "Schema is invalid" };
  }
  const tableSchema = schema.tables[table];
  if (!tableSchema) {
    return { valid: false, errors: [{ message: `Table ${table} not found in schema` }], message: "Table not found" };
  }
  for (const [fieldName, fieldValue] of Object.entries(data)) {
    const fieldSchema = tableSchema.fields[fieldName];
    if (!fieldSchema) {
      return {
        valid: false,
        errors: [{ message: `Field ${fieldName} not found in schema` }],
        message: "Invalid field"
      };
    }
    const schemaType = fieldSchema.type;
    const valueType = typeof fieldValue;
    if (schemaType === "string" && valueType !== "string" || schemaType === "number" && valueType !== "number" || schemaType === "boolean" && valueType !== "boolean" || schemaType === "json" && valueType !== "object") {
      return {
        valid: false,
        errors: [{
          message: `Field ${fieldName} should be type ${schemaType}, got ${valueType}`
        }],
        message: "invalid type"
      };
    }
  }
  if (checkRequired) {
    for (const [fieldName, fieldSchema] of Object.entries(tableSchema.fields)) {
      if (fieldSchema.required && !data[fieldName]) {
        return { valid: false, errors: [{ message: `Field ${fieldName} is required` }], message: "Required field missing" };
      }
    }
  }
  return { valid: true, errors: [] };
}

// src/sync/index.ts
syncProtocol();
var BasicSync = class extends Dexie2 {
  basic_schema;
  constructor(name, options) {
    super(name, options);
    this.basic_schema = options.schema;
    this.version(1).stores(this._convertSchemaToDxSchema(this.basic_schema));
    this.version(2).stores({});
    this.Collection.prototype.get = this.Collection.prototype.toArray;
  }
  async connect({ access_token }) {
    const WS_URL = `${SERVER_URL}/ws`;
    await this.updateSyncNodes();
    log("Starting connection...");
    return this.syncable.connect("websocket", WS_URL, { authToken: access_token, schema: this.basic_schema });
  }
  async disconnect() {
    const WS_URL = `${SERVER_URL}/ws`;
    return this.syncable.disconnect(WS_URL);
  }
  async updateSyncNodes() {
    try {
      const syncNodes = await this.table("_syncNodes").toArray();
      const localSyncNodes = syncNodes.filter((node) => node.type === "local");
      log("Local sync nodes:", localSyncNodes);
      if (localSyncNodes.length > 1) {
        const largestNodeId = Math.max(...localSyncNodes.map((node) => node.id));
        const largestNode = localSyncNodes.find((node) => node.id === largestNodeId);
        if (largestNode && largestNode.isMaster === 1) {
          log("Largest node is already the master. No changes needed.");
          return;
        }
        log("Largest node id:", largestNodeId);
        log("HEISENBUG: More than one local sync node found.");
        for (const node of localSyncNodes) {
          log(`Local sync node keys:`, node.id, node.isMaster);
          await this.table("_syncNodes").update(node.id, { isMaster: node.id === largestNodeId ? 1 : 0 });
          log(`HEISENBUG: Setting ${node.id} to ${node.id === largestNodeId ? "master" : "0"}`);
        }
        await new Promise((resolve) => setTimeout(resolve, 1e3));
        if (typeof window !== "undefined") {
          window.location.reload();
        }
      }
      log("Sync nodes updated");
    } catch (error) {
      console.error("Error updating _syncNodes table:", error);
    }
  }
  handleStatusChange(fn) {
    this.syncable.on("statusChanged", fn);
  }
  _convertSchemaToDxSchema(schema) {
    const stores = Object.entries(schema.tables).map(([key, table]) => {
      const indexedFields = Object.entries(table.fields).filter(([key2, field]) => field.indexed).map(([key2, field]) => `,${key2}`).join("");
      return {
        [key]: "id" + indexedFields
      };
    });
    return Object.assign({}, ...stores);
  }
  debugeroo() {
    return this.syncable;
  }
  collection(name) {
    return {
      /**
       * Returns the underlying Dexie table
       * @type {Dexie.Table}
       */
      ref: this.table(name),
      // --- WRITE ---- // 
      add: (data) => {
        const valid = validateData(this.basic_schema, name, data);
        if (!valid.valid) {
          log("Invalid data", valid);
          return Promise.reject({ ...valid });
        }
        return this.table(name).add({
          id: uuidv7(),
          ...data
        });
      },
      put: (data) => {
        const valid = validateData(this.basic_schema, name, data);
        if (!valid.valid) {
          log("Invalid data", valid);
          return Promise.reject({ ...valid });
        }
        return this.table(name).put({
          id: uuidv7(),
          ...data
        });
      },
      update: (id, data) => {
        const valid = validateData(this.basic_schema, name, data, false);
        if (!valid.valid) {
          log("Invalid data", valid);
          return Promise.reject({ ...valid });
        }
        return this.table(name).update(id, data);
      },
      delete: (id) => {
        return this.table(name).delete(id);
      },
      // --- READ ---- // 
      get: async (id) => {
        return this.table(name).get(id);
      },
      getAll: async () => {
        return this.table(name).toArray();
      },
      // --- QUERY ---- // 
      // TODO: lots to do here. simplifing creating querie,  filtering/ordering/limit, and execute
      query: () => this.table(name),
      filter: (fn) => this.table(name).filter(fn).toArray()
    };
  }
};

// src/db.ts
var baseUrl = "https://api.basic.tech";
async function get({ projectId, accountId, tableName, token }) {
  const url = `${baseUrl}/project/${projectId}/db/${accountId}/${tableName}`;
  const response = await fetch(url, {
    headers: {
      "Authorization": `Bearer ${token}`
    }
  });
  return response.json();
}
async function add({ projectId, accountId, tableName, value, token }) {
  const url = `${baseUrl}/project/${projectId}/db/${accountId}/${tableName}`;
  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${token}`
    },
    body: JSON.stringify({ "value": value })
  });
  return response.json();
}
async function update({ projectId, accountId, tableName, id, value, token }) {
  const url = `${baseUrl}/project/${projectId}/db/${accountId}/${tableName}/${id}`;
  const response = await fetch(url, {
    method: "PATCH",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${token}`
    },
    body: JSON.stringify({ id, value })
  });
  return response.json();
}
async function deleteRecord({ projectId, accountId, tableName, id, token }) {
  const url = `${baseUrl}/project/${projectId}/db/${accountId}/${tableName}/${id}`;
  const response = await fetch(url, {
    method: "DELETE",
    headers: {
      "Authorization": `Bearer ${token}`
    }
  });
  return response.json();
}

// src/AuthContext.tsx
import { validateSchema as validateSchema3, compareSchemas } from "@basictech/schema";

// package.json
var version = "0.5.0-beta.5";

// src/AuthContext.tsx
import { jsx, jsxs } from "react/jsx-runtime";
var BasicContext = createContext({
  unicorn: "\u{1F984}",
  isAuthReady: false,
  isSignedIn: false,
  user: null,
  signout: () => {
  },
  signin: () => {
  },
  getToken: () => new Promise(() => {
  }),
  getSignInLink: () => "",
  db: {},
  dbStatus: "LOADING" /* LOADING */
});
async function getSchemaStatus(schema) {
  const projectId = schema.project_id;
  let status = "";
  const valid = validateSchema3(schema);
  if (!valid.valid) {
    console.warn("BasicDB Error: your local schema is invalid. Please fix errors and try again - sync is disabled");
    return {
      valid: false,
      status: "invalid",
      latest: null
    };
  }
  const latestSchema = await fetch(`https://api.basic.tech/project/${projectId}/schema`).then((res) => res.json()).then((data) => data.data[0].schema).catch((err) => {
    return {
      valid: false,
      status: "error",
      latest: null
    };
  });
  if (!latestSchema.version) {
    return {
      valid: false,
      status: "error",
      latest: null
    };
  }
  if (latestSchema.version > schema.version) {
    console.warn("BasicDB Error: your local schema version is behind the latest. Found version:", schema.version, "but expected", latestSchema.version, " - sync is disabled");
    return {
      valid: false,
      status: "behind",
      latest: latestSchema
    };
  } else if (latestSchema.version < schema.version) {
    console.warn("BasicDB Error: your local schema version is ahead of the latest. Found version:", schema.version, "but expected", latestSchema.version, " - sync is disabled");
    return {
      valid: false,
      status: "ahead",
      latest: latestSchema
    };
  } else if (latestSchema.version === schema.version) {
    const changes = compareSchemas(schema, latestSchema);
    if (changes.valid) {
      return {
        valid: true,
        status: "current",
        latest: latestSchema
      };
    } else {
      console.warn("BasicDB Error: your local schema is conflicting with the latest. Your version:", schema.version, "does not match origin version", latestSchema.version, " - sync is disabled");
      return {
        valid: false,
        status: "conflict",
        latest: latestSchema
      };
    }
  } else {
    return {
      valid: false,
      status: "error",
      latest: null
    };
  }
}
function getSyncStatus(statusCode) {
  switch (statusCode) {
    case -1:
      return "ERROR";
    case 0:
      return "OFFLINE";
    case 1:
      return "CONNECTING";
    case 2:
      return "ONLINE";
    case 3:
      return "SYNCING";
    case 4:
      return "ERROR_WILL_RETRY";
    default:
      return "UNKNOWN";
  }
}
async function checkForNewVersion() {
  try {
    const isBeta = version.includes("beta");
    const response = await fetch(`https://registry.npmjs.org/@basictech/react/${isBeta ? "beta" : "latest"}`);
    if (!response.ok) {
      throw new Error("Failed to fetch version from npm");
    }
    const data = await response.json();
    const latestVersion = data.version;
    if (latestVersion !== version) {
      console.warn("[basic] New version available:", latestVersion, `
run "npm install @basictech/react@${latestVersion}" to update`);
    }
    if (isBeta) {
      log("thank you for being on basictech/react beta :)");
    }
    return {
      hasNewVersion: version !== latestVersion,
      latestVersion,
      currentVersion: version
    };
  } catch (error) {
    log("Error checking for new version:", error);
    return {
      hasNewVersion: false,
      latestVersion: null,
      currentVersion: null
    };
  }
}
function BasicProvider({ children, project_id, schema, debug = false }) {
  const [isAuthReady, setIsAuthReady] = useState(false);
  const [isSignedIn, setIsSignedIn] = useState(false);
  const [token, setToken] = useState(null);
  const [user, setUser] = useState({});
  const [shouldConnect, setShouldConnect] = useState(false);
  const [isReady, setIsReady] = useState(false);
  const [dbStatus, setDbStatus] = useState("OFFLINE" /* OFFLINE */);
  const [error, setError] = useState(null);
  const syncRef = useRef(null);
  useEffect(() => {
    function initDb(options) {
      if (!syncRef.current) {
        log("Initializing BasicDB");
        syncRef.current = new BasicSync("basicdb", { schema });
        syncRef.current.syncable.on("statusChanged", (status, url) => {
          setDbStatus(getSyncStatus(status));
        });
        syncRef.current.syncable.getStatus().then((status) => {
          setDbStatus(getSyncStatus(status));
        });
        if (options.shouldConnect) {
          setShouldConnect(true);
        } else {
          log("Sync is disabled");
        }
        setIsReady(true);
      }
    }
    async function checkSchema() {
      const valid = validateSchema3(schema);
      if (!valid.valid) {
        log("Basic Schema is invalid!", valid.errors);
        console.group("Schema Errors");
        let errorMessage = "";
        valid.errors.forEach((error2, index) => {
          log(`${index + 1}:`, error2.message, ` - at ${error2.instancePath}`);
          errorMessage += `${index + 1}: ${error2.message} - at ${error2.instancePath}
`;
        });
        console.groupEnd("Schema Errors");
        setError({
          code: "schema_invalid",
          title: "Basic Schema is invalid!",
          message: errorMessage
        });
        setIsReady(true);
        return null;
      }
      let schemaStatus = { valid: false };
      if (schema.version !== 0) {
        schemaStatus = await getSchemaStatus(schema);
      }
      if (schemaStatus.valid) {
        initDb({ shouldConnect: true });
      } else {
        initDb({ shouldConnect: false });
      }
      checkForNewVersion();
    }
    if (schema) {
      checkSchema();
    } else {
      setIsReady(true);
    }
  }, []);
  useEffect(() => {
    if (token && syncRef.current && isSignedIn && shouldConnect) {
      connectToDb();
    }
  }, [isSignedIn, shouldConnect]);
  useEffect(() => {
    localStorage.setItem("basic_debug", debug ? "true" : "false");
    try {
      if (window.location.search.includes("code")) {
        let code = window.location?.search?.split("code=")[1].split("&")[0];
        const state = localStorage.getItem("basic_auth_state");
        if (!state || state !== window.location.search.split("state=")[1].split("&")[0]) {
          log("error: auth state does not match");
          setIsAuthReady(true);
          localStorage.removeItem("basic_auth_state");
          window.history.pushState({}, document.title, "/");
          return;
        }
        localStorage.removeItem("basic_auth_state");
        fetchToken(code);
      } else {
        let cookie_token = getCookie("basic_token");
        if (cookie_token !== "") {
          setToken(JSON.parse(cookie_token));
        } else {
          setIsAuthReady(true);
        }
      }
    } catch (e) {
      log("error getting cookie", e);
    }
  }, []);
  useEffect(() => {
    async function fetchUser(acc_token) {
      console.info("fetching user");
      const user2 = await fetch("https://api.basic.tech/auth/userInfo", {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${acc_token}`
        }
      }).then((response) => response.json()).catch((error2) => log("Error:", error2));
      if (user2.error) {
        log("error fetching user", user2.error);
        return;
      } else {
        document.cookie = `basic_token=${JSON.stringify(token)}; Secure; SameSite=Strict`;
        if (window.location.search.includes("code")) {
          window.history.pushState({}, document.title, "/");
        }
        setUser(user2);
        setIsSignedIn(true);
        setIsAuthReady(true);
      }
    }
    async function checkToken() {
      if (!token) {
        log("error: no user token found");
        setIsAuthReady(true);
        return;
      }
      const decoded = jwtDecode(token?.access_token);
      const isExpired = decoded.exp && decoded.exp < Date.now() / 1e3;
      if (isExpired) {
        log("token is expired - refreshing ...");
        const newToken = await fetchToken(token?.refresh);
        fetchUser(newToken.access_token);
      } else {
        fetchUser(token.access_token);
      }
    }
    if (token) {
      checkToken();
    }
  }, [token]);
  const connectToDb = async () => {
    const tok = await getToken();
    if (!tok) {
      log("no token found");
      return;
    }
    log("connecting to db...");
    syncRef.current.connect({ access_token: tok }).catch((e) => {
      log("error connecting to db", e);
    });
  };
  const getSignInLink = () => {
    log("getting sign in link...");
    const randomState = Math.random().toString(36).substring(6);
    localStorage.setItem("basic_auth_state", randomState);
    let baseUrl2 = "https://api.basic.tech/auth/authorize";
    baseUrl2 += `?client_id=${project_id}`;
    baseUrl2 += `&redirect_uri=${encodeURIComponent(window.location.href)}`;
    baseUrl2 += `&response_type=code`;
    baseUrl2 += `&scope=openid`;
    baseUrl2 += `&state=${randomState}`;
    return baseUrl2;
  };
  const signin = () => {
    log("signing in: ", getSignInLink());
    const signInLink = getSignInLink();
    window.location.href = signInLink;
  };
  const signout = () => {
    log("signing out!");
    setUser({});
    setIsSignedIn(false);
    setToken(null);
    document.cookie = `basic_token=; Secure; SameSite=Strict`;
    localStorage.removeItem("basic_auth_state");
    if (syncRef.current) {
      (async () => {
        try {
          await syncRef.current.close();
          await syncRef.current.delete({ disableAutoOpen: false });
          syncRef.current = null;
          window?.location?.reload();
        } catch (error2) {
          console.error("Error during database cleanup:", error2);
        }
      })();
    }
  };
  const getToken = async () => {
    log("getting token...");
    if (!token) {
      log("no token found");
      throw new Error("no token found");
    }
    const decoded = jwtDecode(token?.access_token);
    const isExpired = decoded.exp && decoded.exp < Date.now() / 1e3;
    if (isExpired) {
      log("token is expired - refreshing ...");
      const newToken = await fetchToken(token?.refresh);
      return newToken?.access_token || "";
    }
    return token?.access_token || "";
  };
  function getCookie(name) {
    let cookieValue = "";
    if (document.cookie && document.cookie !== "") {
      const cookies = document.cookie.split(";");
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === name + "=") {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
  const fetchToken = async (code) => {
    const token2 = await fetch("https://api.basic.tech/auth/token", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ code })
    }).then((response) => response.json()).catch((error2) => log("Error:", error2));
    if (token2.error) {
      log("error fetching token", token2.error);
      return;
    } else {
      setToken(token2);
    }
    return token2;
  };
  const db_ = (tableName) => {
    const checkSignIn = () => {
      if (!isSignedIn) {
        throw new Error("cannot use db. user not logged in.");
      }
    };
    return {
      get: async () => {
        checkSignIn();
        const tok = await getToken();
        return get({ projectId: project_id, accountId: user.id, tableName, token: tok });
      },
      add: async (value) => {
        checkSignIn();
        const tok = await getToken();
        return add({ projectId: project_id, accountId: user.id, tableName, value, token: tok });
      },
      update: async (id, value) => {
        checkSignIn();
        const tok = await getToken();
        return update({ projectId: project_id, accountId: user.id, tableName, id, value, token: tok });
      },
      delete: async (id) => {
        checkSignIn();
        const tok = await getToken();
        return deleteRecord({ projectId: project_id, accountId: user.id, tableName, id, token: tok });
      }
    };
  };
  const noDb = {
    collection: () => {
      throw new Error("no basicdb found - initialization failed. double check your schema.");
    }
  };
  return /* @__PURE__ */ jsxs(BasicContext.Provider, { value: {
    unicorn: "\u{1F984}",
    isAuthReady,
    isSignedIn,
    user,
    signout,
    signin,
    getToken,
    getSignInLink,
    db: syncRef.current ? syncRef.current : noDb,
    dbStatus
  }, children: [
    error && /* @__PURE__ */ jsx(ErrorDisplay, { error }),
    isReady && children
  ] });
}
function ErrorDisplay({ error }) {
  return /* @__PURE__ */ jsxs("div", { style: {
    position: "absolute",
    top: 20,
    left: 20,
    color: "black",
    backgroundColor: "#f8d7da",
    border: "1px solid #f5c6cb",
    borderRadius: "4px",
    padding: "20px",
    maxWidth: "400px",
    margin: "20px auto",
    boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)",
    fontFamily: "monospace"
  }, children: [
    /* @__PURE__ */ jsxs("h3", { style: { fontSize: "0.8rem", opacity: 0.8 }, children: [
      "code: ",
      error.code
    ] }),
    /* @__PURE__ */ jsx("h1", { style: { fontSize: "1.2rem", lineHeight: "1.5" }, children: error.title }),
    /* @__PURE__ */ jsx("p", { children: error.message })
  ] });
}
function useBasic() {
  return useContext(BasicContext);
}

// src/index.ts
import { useLiveQuery as useQuery } from "dexie-react-hooks";
export {
  BasicProvider,
  useBasic,
  useQuery
};
//# sourceMappingURL=index.mjs.map