// index.ts
import Ajv from "ajv";
var basicJsonSchema = {
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "project_id": {
      "type": "string"
    },
    "namespace": {
      "type": "string"
    },
    "version": {
      "type": "integer",
      "minimum": 0
    },
    "tables": {
      "type": "object",
      "propertyNames": {
        "pattern": "^[a-zA-Z0-9_]+$",
        "minLength": 1,
        "maxLength": 50,
        "type": "string"
      },
      "patternProperties": {
        "^[a-zA-Z0-9_]+$": {
          "type": "object",
          "propertyNames": {
            "pattern": "^[a-zA-Z0-9_]+$",
            "minLength": 1,
            "maxLength": 50,
            "type": "string"
          },
          "properties": {
            "name": {
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": ["collection"]
            },
            "origin": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "enum": ["reference"]
                },
                "project_id": {
                  "type": "string"
                },
                "table": {
                  "type": "string"
                },
                "version": {
                  "type": "integer"
                }
              },
              "if": {
                "properties": { "type": { "const": "reference" } }
              },
              "then": {
                "required": ["project_id", "table"]
              }
            },
            "fields": {
              "type": "object",
              "propertyNames": {
                "pattern": "^[a-zA-Z0-9_]+$",
                "minLength": 1,
                "maxLength": 50,
                "type": "string"
              },
              "patternProperties": {
                "^[a-zA-Z0-9_]+$": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": ["string", "boolean", "number", "json"]
                    },
                    "indexed": {
                      "type": "boolean"
                    },
                    "required": {
                      "type": "boolean"
                    }
                  },
                  "required": ["type"]
                }
              },
              "additionalProperties": true
            }
          },
          "required": ["fields"]
        }
      },
      "additionalProperties": true
    }
  },
  "required": ["project_id", "version", "tables"]
};
var ajv = new Ajv();
var validator = ajv.compile(basicJsonSchema);
function generateEmptySchema(project_id = "", version = 0) {
  return {
    project_id,
    version,
    tables: {
      foo: {
        name: "foo",
        type: "collection",
        fields: {
          bar: {
            type: "string",
            required: true
          }
        }
      }
    }
  };
}
function compareSchemas(oldSchema, newSchema) {
  const changes = _getSchemaChanges(oldSchema, newSchema);
  const valid = changes.length === 0 ? true : false;
  return { valid, changes };
}
function validateSchema(schema) {
  const v = validator(schema);
  return {
    valid: v,
    errors: validator.errors || []
  };
}
function validateData(schema, table, data, checkRequired = true) {
  const valid = validateSchema(schema);
  if (!valid.valid) {
    return { valid: false, errors: valid.errors, message: "Schema is invalid" };
  }
  const tableSchema = schema.tables[table];
  if (!tableSchema) {
    return { valid: false, errors: [{ message: `Table ${table} not found in schema` }], message: "Table not found" };
  }
  for (const [fieldName, fieldValue] of Object.entries(data)) {
    const fieldSchema = tableSchema.fields[fieldName];
    if (!fieldSchema) {
      return {
        valid: false,
        errors: [{ message: `Field ${fieldName} not found in schema` }],
        message: "Invalid field"
      };
    }
    const schemaType = fieldSchema.type;
    const valueType = typeof fieldValue;
    if (schemaType === "string" && valueType !== "string" || schemaType === "number" && valueType !== "number" || schemaType === "boolean" && valueType !== "boolean" || schemaType === "json" && valueType !== "object") {
      return {
        valid: false,
        errors: [{
          message: `Field ${fieldName} should be type ${schemaType}, got ${valueType}`
        }],
        message: "invalid type"
      };
    }
  }
  if (checkRequired) {
    for (const [fieldName, fieldSchema] of Object.entries(tableSchema.fields)) {
      if (fieldSchema.required && !data[fieldName]) {
        return { valid: false, errors: [{ message: `Field ${fieldName} is required` }], message: "Required field missing" };
      }
    }
  }
  return { valid: true, errors: [] };
}
function _getSchemaChanges(oldSchema, newSchema) {
  const changes = [];
  for (const key in newSchema) {
    if (key !== "tables" && newSchema[key] !== oldSchema[key]) {
      changes.push({
        type: "property_changed",
        property: key,
        old: oldSchema[key],
        new: newSchema[key]
      });
    }
  }
  for (const key in oldSchema) {
    if (key !== "tables" && !newSchema.hasOwnProperty(key)) {
      changes.push({
        type: "property_removed",
        property: key,
        old: oldSchema[key]
      });
    }
  }
  for (const tableName in oldSchema.tables) {
    if (!newSchema.tables[tableName]) {
      changes.push({
        type: "table_removed",
        table: tableName
      });
    }
  }
  for (const tableName in newSchema.tables) {
    const newTable = newSchema.tables[tableName];
    const oldTable = oldSchema.tables[tableName];
    if (!oldTable) {
      changes.push({
        type: "table_added",
        table: tableName
      });
      continue;
    }
    for (const fieldName in newTable.fields) {
      const newField = newTable.fields[fieldName];
      const oldField = oldTable.fields[fieldName];
      if (!oldField) {
        changes.push({
          type: "field_added",
          table: tableName,
          field: fieldName
        });
        continue;
      }
      if (newField.type !== oldField.type) {
        changes.push({
          type: "field_type_changed",
          table: tableName,
          field: fieldName,
          old: oldField.type,
          new: newField.type
        });
      }
      if (newField.required !== oldField.required) {
        changes.push({
          type: "field_required_changed",
          table: tableName,
          field: fieldName,
          old: oldField.required,
          new: newField.required
        });
      }
    }
    for (const fieldName in oldTable.fields) {
      if (!newTable.fields[fieldName]) {
        changes.push({
          type: "field_removed",
          table: tableName,
          field: fieldName
        });
      }
    }
  }
  for (const tableName in newSchema.tables) {
    const newTable = newSchema.tables[tableName];
    const oldTable = oldSchema.tables[tableName];
    if (!oldTable)
      continue;
    for (const fieldName in newTable.fields) {
      const newField = newTable.fields[fieldName];
      const oldField = oldTable.fields[fieldName];
      if (!oldField)
        continue;
      for (const prop in newField) {
        if (prop === "type")
          continue;
        if (!(prop in oldField)) {
          changes.push({
            type: "field_property_added",
            table: tableName,
            field: fieldName,
            property: prop,
            new: newField[prop]
          });
        } else if (JSON.stringify(newField[prop]) !== JSON.stringify(oldField[prop])) {
          changes.push({
            type: "field_property_changed",
            table: tableName,
            field: fieldName,
            property: prop,
            old: oldField[prop],
            new: newField[prop]
          });
        }
      }
      for (const prop in oldField) {
        if (prop === "type")
          continue;
        if (!(prop in newField)) {
          changes.push({
            type: "field_property_removed",
            table: tableName,
            field: fieldName,
            property: prop,
            old: oldField[prop]
          });
        }
      }
    }
  }
  return changes;
}
function validateUpdateSchema(oldSchema, newSchema) {
  const oldValid = validateSchema(oldSchema);
  const newValid = validateSchema(newSchema);
  if (!oldValid.valid || !newValid.valid) {
    return { valid: false, errors: oldValid.errors.concat(newValid.errors), message: "schemas are is invalid" };
  }
  const changes = _getSchemaChanges(oldSchema, newSchema);
  const changeErrors = [];
  for (const change of changes) {
    if (change.type === "property_changed" && change.property === "project_id") {
      changeErrors.push({
        change,
        message: "Cannot modify project_id property"
      });
    }
    if (change.type === "property_changed" && change.property === "version") {
      if (change.new !== change.old + 1) {
        changeErrors.push({
          change,
          message: `Version must be incremented by 1. Expected version:${change.old + 1}, got version:${change.new}`
        });
      }
    }
    if (change.type === "field_type_changed") {
      changeErrors.push({
        change,
        message: `Cannot change type of field "${change.field}" from "${change.old}" to "${change.new}"`
      });
    }
  }
  if (changeErrors.length > 0) {
    return {
      valid: false,
      errors: changeErrors,
      message: "Invalid schema changes detected"
    };
  }
  return { valid: true, changes, errors: [] };
}
function getJsonSchema() {
  return basicJsonSchema;
}
export {
  compareSchemas,
  generateEmptySchema,
  getJsonSchema,
  validateData,
  validateSchema,
  validateUpdateSchema
};
//# sourceMappingURL=index.mjs.map